<html>
<script src="/socket.io/socket.io.js"></script>
<head>
<style>
#canvas{
border:1px solid black

}
</style>
</head>

<body onload="setup()"  onkeyup="keyUpEvent(event)" onkeydown="keyDownEvent(event)" height="100%" scroll="no" style="overflow: hidden">
<p id="console" style="float:right"></p>
<canvas onwheel="wheelEvent(event)" id="canvas" onmouseup="mouseUpEvent(event)" onmousedown="mouseDownEvent(event)" onmousemove="mouseMoveEvent(event)" width="1280px" height="720px"></canvas>

<canvas id="buffer" width="1280px" height="720px" display="none"></canvas>

<img id="img"/>





</body>


<script>
const console = document.getElementById("console") //loading debug console
const canvas = document.getElementById("canvas") //loading display canvas
const buffer = document.getElementById("buffer") //loading buffer canvas



class graphics {
    
    constructor(canvas, buffer, images){
        
        this.canvas = document.getElementById(canvas)
        this.ctx = this.canvas.getContext("2d")
        this.buffer = document.getElementById(buffer)
        this.buf = this.buffer.getContext("2d")
        this.images=images
        this.camera=[0,0,0]
        
        
    }
    
    swapbuffer(){
        this.ctx.clearRect(0, 0, this.buffer.width, this.buffer.height);
        this.ctx.drawImage(this.buffer, 0, 0)
        this.buf.clearRect(0, 0, this.buffer.width, this.buffer.height);
        
    }
    
    drawsprite(image, x, y, rot, scale){
		
        let nx = (x-this.camera[0]+this.canvas.width/(1.5**this.camera[2])/2)*(1.5**this.camera[2])
        let ny = (y-this.camera[1]+this.canvas.height/(1.5**this.camera[2])/2)*(1.5**this.camera[2])
		this.buf.translate(nx, ny)
		this.buf.rotate(rot)
        this.buf.drawImage(images[image], -images[image].width*scale/2*(1.5**this.camera[2]), -images[image].height*scale/2*(1.5**this.camera[2]), images[image].width*scale*(1.5**this.camera[2]), images[image].height*scale*(1.5**this.camera[2]))
		this.buf.rotate(-rot)
		this.buf.translate(-nx, -ny)
		
    }
    
    
}



async function setup(){
                                    //loading images used as sprite to be drawn onto the screen
    socket = io()
    socket.on("wallUpdate", (walls)=>{
        walllist=walls
    })
    let response = await fetch("filelist");
    let files = await response.json();
    images={}
    files.forEach(file=>{
        let image=new Image()
        image.src="/assets/"+file
        images[file]=image
    })
    document.body.appendChild(images["block.png"])
    counter=0
    graph = new graphics("canvas", "buffer", images)
    ctx=canvas.getContext("2d")
    buf=buffer.getContext("2d")
	forw=false
    back=false
    left=false
    righ=false
    
    socket.on("frameUpdate", (positions)=>{
        for(i=0; i<positions.length; i++){
            graph.drawsprite("player1.png", positions[i][0], positions[i][1], -positions[i][2]+(Math.PI/2), 1)
            graph.drawsprite("arrow1.png",  positions[i][0], positions[i][1], -positions[i][3]+(Math.PI/2), 2)
        }
        for(i=0; i<walllist.length; i++){
            if(walllist[i][2]==20){
                graph.drawsprite("horiwall.png", walllist[i][0], walllist[i][1], 0, 1)
            }else{
                graph.drawsprite("vertwall.png", walllist[i][0], walllist[i][1], 0, 1)
            }
        }
        graph.swapbuffer()
    })
    
    socket.on("positionUpdate", (pos)=>{
        graph.camera[0]=pos[0]
        graph.camera[1]=pos[1]
        
    
    })
    
    socket.on("debugUpdate", (poss)=>{
        for (let i =0; i<poss.length; i++){
            let nx = (poss[i][0]-graph.camera[0]+graph.canvas.width/(1.5**graph.camera[2])/2)*(1.5**graph.camera[2])
            let ny = (poss[i][1]-graph.camera[1]+graph.canvas.height/(1.5**graph.camera[2])/2)*(1.5**graph.camera[2])
            buf.beginPath();
            buf.arc(nx, ny, 3, 0, 2 * Math.PI);
            buf.fill();
                        
        }
    })
}







async function wheelEvent(event){
    graph.camera[2]-=event.deltaY/1000.0
}

async function keyDownEvent(event){
    socket.emit("pressedKey", event.code)
}

async function keyUpEvent(event){
    socket.emit("releasedKey", event.code)
}

async function mouseMoveEvent(event){
    let x=(event.x-648)
    let y=(event.y-368)
    if(y==0){y++}
    let rot=Math.acos(x/Math.sqrt(x**2+y**2))*Math.sign(y)%(2*Math.PI)
    if(rot<0){
        rot+=2*Math.PI
    }
    rot=Math.abs(rot-(2*Math.PI))
    console.innerHTML=rot
    
    socket.emit("movedMouse", rot)
}










































</script>


</html>

